"""
Search query generation for YouTube video discovery
Uses LLM to create optimized search queries from section learning objectives
"""

import logging
from typing import List, Dict

from utils.llm_handler import call_openai
from populator.video_prompts import get_search_query_generation_prompt

# Initialize logger
logger = logging.getLogger(__name__)


def generate_queries_for_section(
    section: Dict,
    grade_level: str,
    teacher_comments: str = ""
) -> List[Dict]:
    """
    Generate 1-3 YouTube search queries for a section using LLM.
    
    Args:
        section: Section data from course outline
        grade_level: Grade level of students
        teacher_comments: Teacher's special requirements/objectives
    
    Returns:
        list: Query dictionaries with priority and rationale, format:
            [{
                'priority': 'primary|secondary|tertiary',
                'query': str,
                'rationale': str
            }, ...]
    
    Example:
        >>> queries = generate_queries_for_section(
        ...     {'title': 'Photosynthesis', 'components': {...}},
        ...     '5'
        ... )
        >>> queries[0]['priority']
        'primary'
    """
    logger.info(f"Generating search queries for: {section.get('title', 'Unknown')}")
    
    try:
        # Get the prompt (includes teacher comments and detailed objectives)
        prompt = get_search_query_generation_prompt(section, grade_level, teacher_comments)
        
        # Call LLM
        system_message = (
            "You are an expert at creating effective YouTube search queries for "
            "educational content. You generate targeted queries that find high-quality, "
            "age-appropriate videos based on detailed learning objectives."
        )
        
        response = call_openai(prompt, system_message)
        
        # Extract queries
        queries = response.get('queries', [])
        
        if not queries:
            logger.warning("No queries generated by LLM, using fallback")
            return _generate_fallback_queries(section, grade_level)
        
        # Display generated queries
        for query_data in queries:
            priority = query_data.get('priority', 'unknown').capitalize()
            query = query_data.get('query', '')
            logger.info(f"  {priority}: '{query}'")
        
        return queries
    
    except Exception as e:
        logger.error(f"Error generating queries: {e}")
        logger.info("Using fallback queries...")
        return _generate_fallback_queries(section, grade_level)


def _generate_fallback_queries(section: Dict, grade_level: str) -> List[Dict]:
    """
    Generate simple fallback queries if LLM fails.
    
    Args:
        section: Section data
        grade_level: Grade level
    
    Returns:
        list: Basic query list
    """
    section_title = section.get('title', '')
    
    # Extract keywords if available
    instruction = section.get('components', {}).get('instruction', {})
    keywords = instruction.get('content_keywords', [])
    
    # Build queries
    queries = []
    
    # Primary: section title + top keyword
    if keywords:
        primary_query = f"{section_title} {keywords[0]}"
    else:
        primary_query = section_title
    
    queries.append({
        "priority": "primary",
        "query": primary_query[:50],  # Truncate if too long
        "rationale": "Fallback query using section title and keywords"
    })
    
    # Secondary: simplified version
    queries.append({
        "priority": "secondary",
        "query": f"{section_title} explained",
        "rationale": "Fallback explanatory query"
    })
    
    logger.info(f"Generated {len(queries)} fallback queries")
    
    return queries